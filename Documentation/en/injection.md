# Внедрение
Частично внедрение зависимостей было рассмотрено в предыдущей главе - внедрение через метод инициализации. Но существует два других варианта внедрения: через свойства и через методы.

## Внедрение зависимостей
Для указания зависимостей через свойства или любой другой метод, надо перед этим создать объект, в который мы будем внедрять зависимости. Можно это сделать и внутри блока, в котором создается объект, но такой способ не предпочтителен. Для таких случаев существует метод `injection`, который может быть написан несколько раз: 
```Swift
builder.register(type: Home.self).initial { Home() }
  .injection { container, home in try home.animals.append(container.resolve(Cat.self)) }
  .injection { container, home in try home.animals.append(container.resolve(Dog.self)) }
  .injection { container, home in try home.animals.append(container.resolve(Hamster.self)) }
```
Данный метод очень похож на метод инициализации, но у него есть одно главное отличие: вторым аргументом он принимает созданный объект.

По аналогии с методом инициализации, этот метод поддерживает похожие способы сокращения:
```Swift
builder.register(type: Home.self).initial { Home() }
  .injection { home, cat in home.animals.append(cat as Cat) }
  .injection { $0.animals.append($1 as Dog) }
  .injection { $0.hamster = $1 } // автоматически выведет тип
```
!! Обращаю внимание на существенное отличие - в первом случае нулевым параметром идет контейнер, а первым объект. Во втором же случае нулевым параметром идет объект, в который внедряются зависимости, а за ним уже идут объекты, которые внедряются.

## Автоматическое внедрение зависимостей через свойства
Если вы не используете чистые Swift типы, что является частично правдой, так как UI является Obj-C кодом, то существует способ автоматически внедрить все зависимости через свойства без необходимости их перечислять. Но это накладывает два ограничения:
* Тип, в который внедряются должен быть наследован от `NSObject`
* Тип, который внедряется должен быть наследован от `NSObject`
Но при этом снимает ограничение на область видимости - типы могут быть и приватными.
В моем понимании самое удачное применение этой возможности является ViewController:
```Swift
class YourViewController: UIViewController {
  private var inject1: Inject1!
  private var inject2: Inject2!
  ...
}
```
А теперь, давайте сравним два синтаксиса для внедрения (обращаю внимание, что для старого варианта нужно убрать `private`):
```Swift
/// Старый
builder.register(vc: YourViewController.self)
  .inject { vc, inject in vc.inject1 = inject }
  .inject { vc, inject in vc.inject2 = inject }
  .inject { vc, inject in vc.inject3 = inject }
  ...

/// Новый
builder.register(vc: YourViewController.self)
  .useAutoPropertyInjection()
```
Новый вариант дал правильный вариант для области видимости, и по факту наложил всего одно ограничение: `Inject1`, `Inject2`,... должны быть наследованы от `NSObject`.

## Циклические ссылки
Метод `injection` существует, не только для улучшения читабельности кода, но он также выполняет еще одну важную функцию: благодаря ему, возможно указание циклических зависимостей:
```Swift
class Cat: Animal {
  init(home: Home) { ... }
}
class Home {
  var animals: [Animal] = []
}

...
builder.register(type: Cat.self).initial { c in Cat(home: c.resolve()) }
builder.register{ Home() }.injection { $0.animals.append($1 as Cat) }
```
Как видим, в данном примере Кошка знает, где её дом, а дом знает, что в нем живет кошка. Если бы кошка и дом указывали свои зависимости в методе инициализации, то библиотека не смогла бы создать ни кошку, ни дом, так как на момент создания пары, один из объектов еще не создан.

Библиотека не требует указывать явно, что имеются циклические зависимости. Во время разрешения зависимостей библиотека анализирует ситуацию и сама решает, есть ли циклические зависимости или нет.

!! Данный пример является одним из самых простых вариантов циклической зависимости. В библиотеке имеется 7 различных тестов, которые проверяют разные варианты циклических зависимостей для 2, 3 объектов и если объекты внедряются дважды.

## Внедрение с рантайм аргументами
!! Данный функционал доступен, только если его подключить отдельно.
В некоторых случаях чтобы создать объект, нужна дополнительная информация, которую мы можем получить только в ходе исполнения программы. К примеру, есть класс `Dog`, но кличка собаки заранее не известна:
```Swift
class Dog {
  init(name: String) { ... }
}

...
builder.register(type: Dog.self).initialWithArg { _, name in Dog(name: name) }
```
В примере объявляется тип `Dog` и указывается ему метод инициализации, принимающий имя собаки. Обращаю внимание, что при указании параметров всегда присутствует первый параметр `container`.

Библиотека допускает указать через запятую неограниченное количество параметров (на самом деле до 10, но это число легко расширяется). 

Чтобы не ограничивать пользователя библиотекой была добавлена возможность указывать неограниченное количество методов инициализации, но с одним условием - все методы должны иметь разную сигнатуру по типам и количеству типов:
```Swift
class Hamster {
  init(name: String) { ... }
  init(name: String, species: String) { ... }
  ...
}
...
builder.register(type: Hamster.self)
  .initialWithArg { _, name in Hamster(name: name) }
  .initialWithArg { _, name, species in Hamster(name: name, species: species) }
```
В примере выше тип `Hamster` имеет два метода инициализации, с разным количество параметров.

Swift позволяет записать эту запись короче:
```
builder.register(type: Hamster.self)
  .initialWithArg { Hamster(name: $1) }
  .initialWithArg { Hamster(name: $1, species: $2) }
```
!! Обращаю внимание, что все параметры начинаются с 1, а не с 0, так как под 0 доступно обращение к container.

#### [Главная](main.md)
#### [Предыдущая глава "Регистрация"](registration.md#Регистрация)
#### [Следующая глава "Создание контейнера"](build.md#Создание-контейнера)
