# Время жизни

Любой объект имеет время жизни. Для упрощения работы с объектами был создан ARC, но даже его наличие не покрывает все нужды. Так бывают случаи, когда объект может понадобиться в любое время, но при этом большую часть времени он никому не нужен. В принципе такие объекты являются одним из паттернов программирования и называются "одиночки".

В библиотеке время жизни объявляется у компонентов с помощью метода `lifetime`, который принимает один из возможных вариантов перечисления: `.single`, `.lazySingle`, `.weakSingle`, `.perScope`, `.perDependency`

## Одиночка (single)
Если объект в программе существует на протяжении всего жизненного цикла программы в единственном экземпляре, то такой объект называется "одиночка". На самом деле в случае с библиотекой объект существует с момента создания контейнера и до завершения программы. Чтобы зарегистрировать компонент, который будет иметь единственный экземпляр класса в программе, надо объявить его как `.single`:
```Swift
builder.register{ Cat() }.lifetime(.single)
```

## Отложенная одиночка (lazySingle)
Если объект в программе существует на протяжении всего жизненного цикла программы в единственном экземпляре, но при этом создается он при первом обращении, то такой объект называется "отложенная одиночка". Чтобы зарегистрировать компонент, который будет иметь единственный экземпляр класса в программе, но при этом он будет создан при первом обращении, надо объявить его как `.lazySingle`:
```Swift
builder.register{ Cat() }.lifetime(.lazySingle)
```

## Слабая одиночка (weakSingle)
Если объект в программе существует в единственном экземпляре в любой момент времени пока исползуется, то такой объект называется "слабая одиночка". То есть два экзмепляра объекта не могут существовать одновременно, но если будут потеряны все сильные ссылки на него, то объект удалится. Чтобы зарегистрировать компонент, который будет иметь единственный экземпляр класса в программе, но при этом он может быть пересоздан, надо объявить его как `.weakSingle`:
```Swift
builder.register{ Cat() }.lifetime(.weakSingle)
```

## Область видимости (perScope)
Scope - это специальный объект, который содержится в контейнере. Также как у программы могут быть объекты, которые существуют в единственном экземпляре, также и у каждого scope могут быть объекты которые уникальные и единственны для него. То есть если написать:
```Swift
builder.register{ Cat() }.lifetime(.perScope)
```
то кошка будет единственна, для каждого scope. Если scope в программе 1, то это время жизни будет эквивалентно `lazySingle`.

Чтобы создать новый scope, можно зарегистрировать другие типы и создать новый контейнер или же можно создать копию контейнера:
```Swift
let newcontainer = container.newLifeTimeScope()
```

В этом случае создастся идентичная копия контейнера, но с новым пустым scope:
```Swift
let cat1: Cat = try! container.resolve()
let equalsCat1: Cat = try! container.resolve()
let newcontainer = container.newLifeTimeScope()
let cat2: Cat = try! newcontainer.resolve()
let equalsCat2: Cat = try! newcontainer.resolve()
assert(cat1 === equalsCat1)
assert(cat2 === equalsCat2)
assert(cat1 !== cat2)
```

## Перемещение области видимости
Если же возникает обратная ситуация - есть несколько контейнеров, а хочется чтобы у них была одна область видимости, то существует функция `useScope(from:)` которая позволяет заменить scope у контейнера:
```Swift
container2.useScope(from: container)
let cat1: Cat = try! container.resolve()
let cat2: Cat = try! container2.resolve()
assert(cat1 === cat2)
```
!! Используйте эту функцию только при создании контейнера, так как если в scope контейнера уже есть объекты, то они будут затерты, а в debug будет брошен assert.

## Всегда новый (perDependency)
Самое простое в понимании время жизни - каждый раз при запросе у контейнера объекта, создается новый экземпляр. Объявляется он аналогичным образом:
```Swift
builder.register{ Cat() }.lifetime(.perDependency)
```

## По умолчанию (default)
Если у компоненты не указано время жизни, то используется `perScope`.


#### [Главная](main.md)
#### [Предыдущая глава "Указанием имени/множественная регистрация"](multi_name_registration.md)
#### [Следующая глава "Компоненты"](component.md)