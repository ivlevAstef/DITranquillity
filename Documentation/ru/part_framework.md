# Части и Фреймворки
Часть - объединение разных компонент, по некоторым характеристикам.
Фреймворк - объединение разных частей и компонент, по некоторым характеристикам. Но! предполагается, что эта сущность будет единственная на bundle/framework в обычном понимании apple.

Фреймворк является некоторой надстройкой над часть, и в будущем если мы говорим что-то о части, то это автоматически применимо и в фреймворке.

## Объявление
прежде чем использовать часть, ее нужно объявить. Так как часть является следующей ступенью над типом, а тип в библиотеке представляется в виде функций, логично представить часть в виде класса. Чтобы объявить часть нужно:
* Создать свой класс
* Объявить, что класс реализует протокол `DIPart`
* Реализовать метод `static load(container: DIContainer)`

```Swift
class RegistrationPart: DIPart {
  static func load(container: DIContainer) {
    container.register...
  }
}
```
Обращаю внимание что функция `load` статическая - это нужно для того, чтобы не создавать экземпляр класса каждый раз когда нужно вызвать функцию.

Для объявления фреймворка нужно сделать анологичные действия, только базовый протокол другой: `DIFramework`:
```Swift
class RegistrationFramework: DIFramework {
  static func load(container: DIContainer) {
    container.register...
  }
}
```

## Регистрация
После того как мы объявили часть, ее нужно добавить в контейнер, чтобы он смог ей воспользоваться:
```Swift
container.append(part: RegistrationPart.self)
```
Для фреймворка есть другой синтаксис:
```Swift
container.append(framework: RegistrationFramework.self)
```


## Импорт
То чем фреймворк отличительно отличается от части, так это тем что он может импортировать другие фреймворки. Смысл импортирования очень похож на обычный `import` у языка swift - он только говорит, что можно использовать информацию из другого фреймворка, но не обязывает это делать.
```Swift
class RegistrationFramework: DIFramework {
  static func load(container: DIContainer) {
    container.import(OtherYourFramework.self)
  }
}
```
Но обращаю внимание - используйте этот  функционал с осторожностью соблюдая то для чего он предназначен. К сожалению библиотека не сильно разборчивая, и не способна угадать откуда на самом деле была вызвана эта функция. Поэтому для этих целей она берет Bundle  части или фреймворка который добавлялся в контейнер самым последним. Поэтому советую всегда использовать импорт только внутри фреймворка и желательно в самом начале функции `load`. Не рекомендую выносить это в отдельные функции дабы не запутаться в межмодульных зависимостях.

Также обращаю внимание, что библиотека в права сама решать когда ей стоит брать зависимости из других модулей. То есть импорт это не просто указание, что можно брать, а это скорее помощь библиотеке, в случае возникновения спорных ситуаций.

#### [Главная](main.md)
#### [Предыдущая глава "Время жизни"](lifetime.md#Время-жизни)
#### [Следующая глава "Storyboard"](storyboard.md#storyboard)
