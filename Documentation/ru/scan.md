# Поиск

В крупных проекта может насчитываться десятки, а то и сотни модулей. И в каждом подпроекте может быть сотни компонент.
Упоминать все эти зависимости может стать утомительным делом - добавился новый компонент, надо его не забыть внести в список компонентов, удалился модуль - надо удалить на него зависимости, и т.д.

В таких случая намного удобней придумать простое правило, по которому модуля и компоненты будут искаться автоматически. К примеру, все модули оканчиваются на фразу "Module", а все компоненты именуются как "Component".
Тогда следуя таким правилам, добавление модуля или компоненты, будет делаться проще.

На самом деле все идеально не будет, так как создание/удаление модуля/компонента, это не только создание/удаление зависимостей на него, но и также изменение логики. Библиотека не может отвечать за логику, но она может упростить взаимодействие с зависимостями.

## Предыстория
Swift в отличие от Obj-C, не поддерживает Runtime, но кое какие возможности из Obj-C работают и на Swift классах.

По причинам ограничения Swift в этой части, не получиться на прямую использовать модули и компоненты чтобы их отыскать, но и добавление этой возможности не несет сложностей: достаточно модуль или компонент унаследовать от класса `DIScanned`. 
P.S. На самом деле я не уверен, что данный нюанс это плохо – в таком случае идет явное указание, что модули или компоненты могут быть найдены, и не получится случайно включить что-нибудь лишнее.

## Поиск модулей
Чтобы организовать поиск модулей, как было описано выше вначале нужно модуля наследовать от `DIScanned`:
```swift
class YourModule: DIScanned, DIModule {
  ...
}
```

После чего чтобы найти все модули, которые объявлены как `DIScanned` и удовлетворяю указанному правилу, достаточно зарегистрировать специальный модуль `DIScanModule`:
```swift
builder.register(module: DIScanModule(predicateByName: { $0.contains("Module") }))
```

## Поиск компонент
Поиск компонент идентичен процессу поиска модулей. Вначале наследуемся от `DIScanned`:
```swift
class YourComponent: DIScanned, DIComponent {
  ...
}
```

После регистрируем сборку: `DIScanComponent`:
```swift
builder.register(component: DIScanComponent(predicateByName: { $0.contains("Component") }))
```

## Указание Bundle
Когда проект слишком большой и состоит из многих подпроектов создавать уникальные правила для каждого подпроекта не удобно. Но на iOS каждый подпроект имеет свой уникальный Bundle, а это значит, что можно организовать поиск компонент внутри заданного подпроекта:
```swift
DIScanComponent(predicateByName: { $0.contains("Component") }, in: Bundle(/*create*/))
```

## Возможности
* `DIScanModule` и `DIScanComponent` поддерживают не только предикат по имени, но и предикат по типу:
```swift
builder.register(module: DIScanModule(predicateByType: { $0() is YourBaseModule() }))
// Тут будут включены в сборку все модуля, которые унаследованы от базового модуля
// Обращаю внимание, что тут создается экземпляр объекта, это возможно из-за того что наследование начинается от DIScanned
```

* Указывать Bundle можно и для DIScanModule, но нужно это реже:
```swift
DIScanModule(predicateByName: { $0.contains("Module") }, in: Bundle(/*create*/))
```
* Так как `DIScanModule` и `DIScanComponent` сами являются модулем и компонентом то, это позволяет писать так:
```swift
class YourMainModule: DIModule {
  var components: [DIComponent] = [DIScanComponent(predicateByName: { $0.contains("Component") })]

  var dependencies: [DIModule] = [DIScanModule(predicateByName: { $0.contains("Module") })]
}
```

#### [Главная](main.md)
#### [Предыдущая глава "Storyboard"](storyboard.md)
#### [Следующая глава "Исключения"](errors.md)
